---
title: Metal Backend
description: Apple Silicon GPU acceleration using Metal
---

# Metal Backend

The Metal backend provides high-performance NTT and polynomial operations on Apple Silicon GPUs using Metal Shading Language (MSL).

## Overview

Metal is the optimal backend for macOS and iOS development, offering:
- Native Apple Silicon support (M1, M2, M3 series)
- Unified memory architecture (no host-device copies)
- Sub-microsecond kernel launch latency
- Seamless integration with lux-gpu

## Hardware Requirements

- **macOS 12+** or **iOS 15+**
- Apple Silicon (M1/M2/M3) or AMD/Intel GPU with Metal support
- At least 8GB unified memory recommended for large polynomials

## Enabling Metal

### CMake Configuration

```bash
cmake -B build \
  -DLATTICE_BACKEND_METAL=ON \
  -DLATTICE_BACKEND_CUDA=OFF \
  -DLATTICE_BACKEND_CPU=ON
cmake --build build
```

### Runtime Selection

```cpp
#include <lux/lattice/lattice.h>

// Check Metal availability
if (lattice_metal_available()) {
    lattice_set_backend(LATTICE_BACKEND_METAL);
}

// Verify backend
LatticeBackend current = lattice_get_backend();
printf("Using: %s\n", lattice_backend_name(current));
```

### Go Backend Selection

```go
import "github.com/luxfi/lattice"

// Set Metal backend
if err := lattice.SetBackend(lattice.BackendMetal); err != nil {
    // Fall back to CPU
    lattice.SetBackend(lattice.BackendCPU)
}

// Check GPU availability
if lattice.IsGPUAvailable() {
    fmt.Println("Metal GPU acceleration enabled")
}
```

## Performance Characteristics

### NTT Performance on M3 Max

| Dimension | Forward NTT | Inverse NTT | Batch NTT (1000) |
|-----------|-------------|-------------|------------------|
| n=1024 | 2.1μs | 2.3μs | 0.8ms |
| n=2048 | 4.5μs | 4.8μs | 1.7ms |
| n=4096 | 9.2μs | 9.8μs | 3.5ms |
| n=8192 | 19μs | 20μs | 7.2ms |
| n=16384 | 42μs | 45μs | 15ms |
| n=32768 | 95μs | 100μs | 35ms |

### Memory Bandwidth

Apple Silicon's unified memory architecture provides exceptional bandwidth:

| Chip | Memory Bandwidth | Typical NTT Throughput |
|------|-----------------|------------------------|
| M1 | 68 GB/s | 150M coefficients/s |
| M1 Pro/Max | 200-400 GB/s | 500M coefficients/s |
| M2 | 100 GB/s | 220M coefficients/s |
| M2 Pro/Max | 200-400 GB/s | 550M coefficients/s |
| M3 | 100 GB/s | 250M coefficients/s |
| M3 Pro/Max | 150-400 GB/s | 600M coefficients/s |

## Metal Shader Implementation

### NTT Kernel Structure

```metal
// Metal shader for Cooley-Tukey NTT butterfly
kernel void ntt_butterfly(
    device uint64_t* poly [[buffer(0)]],
    constant uint64_t* twiddles [[buffer(1)]],
    constant NTTParams& params [[buffer(2)]],
    uint tid [[thread_position_in_grid]]
) {
    uint64_t q = params.q;
    uint64_t q_inv = params.q_inv;

    // Compute butterfly indices
    uint step = params.step;
    uint half_step = step >> 1;
    uint group = tid / half_step;
    uint idx = tid % half_step;

    uint i = group * step + idx;
    uint j = i + half_step;

    // Load values
    uint64_t a = poly[i];
    uint64_t b = poly[j];
    uint64_t w = twiddles[group];

    // Montgomery multiplication: t = b * w mod q
    uint64_t t = mont_mul(b, w, q, q_inv);

    // Butterfly: (a + t, a - t)
    poly[i] = add_mod(a, t, q);
    poly[j] = sub_mod(a, t, q);
}
```

### Montgomery Multiplication on Metal

```metal
// Efficient Montgomery multiplication
inline uint64_t mont_mul(uint64_t a, uint64_t b,
                         uint64_t q, uint64_t q_inv) {
    // 128-bit product via Metal's math library
    uint64_t lo, hi;
    mulwide(a, b, lo, hi);

    // Montgomery reduction
    uint64_t m = lo * q_inv;
    uint64_t mn_lo, mn_hi;
    mulwide(m, q, mn_lo, mn_hi);

    // Add and take high part
    uint64_t carry = (lo + mn_lo < lo) ? 1 : 0;
    uint64_t result = hi + mn_hi + carry;

    // Final reduction
    return (result >= q) ? result - q : result;
}
```

## Batch Processing

Metal excels at batch operations due to GPU parallelism:

```cpp
// Process 1000 polynomials in parallel
LatticeNTTContext* ctx;
lattice_ntt_create(&ctx, 4096, 0x7ffe0001ULL);

// Allocate batch buffer
size_t batch_size = 1000;
uint64_t* polys = lattice_poly_batch_alloc(ctx, batch_size);

// Sample all polynomials
LatticePRNG* prng = lattice_prng_system();
for (size_t i = 0; i < batch_size; i++) {
    lattice_sample_uniform(ctx, polys + i * 4096, prng);
}

// Batch NTT - highly efficient on Metal
lattice_ntt_batch_forward(ctx, polys, batch_size);
```

### Go Batch Processing

```go
// Batch operations in Go
ring, _ := lattice.NewRing(4096, []uint64{0x7ffe0001})

// Create batch of polynomials
polys := make([]*lattice.Poly, 1000)
for i := range polys {
    polys[i] = ring.NewPoly()
    ring.SampleUniform(polys[i])
}

// Batch NTT
ring.BatchNTT(polys)
```

## Memory Management

### Unified Memory Benefits

```cpp
// On Metal, unified memory means zero-copy between CPU and GPU
uint64_t* poly = lattice_poly_alloc(ctx);

// CPU can write directly
for (size_t i = 0; i < n; i++) {
    poly[i] = some_value;
}

// GPU operations use same memory
lattice_ntt_forward(ctx, poly);  // No copy needed

// CPU reads result directly
uint64_t first = poly[0];  // No copy needed
```

### Memory Pooling

```cpp
// Enable memory pooling for repeated allocations
lattice_enable_memory_pool(ctx, 100);  // Pool for 100 polys

// Allocations reuse pooled memory
for (int i = 0; i < 10000; i++) {
    uint64_t* poly = lattice_poly_alloc(ctx);
    // ... use poly ...
    lattice_poly_free(poly);  // Returns to pool
}

lattice_disable_memory_pool(ctx);
```

## Synchronization

### Automatic vs Manual Sync

```cpp
// Default: Automatic synchronization
lattice_ntt_forward(ctx, poly);  // Blocks until complete

// Manual synchronization for pipelining
lattice_set_sync_mode(ctx, LATTICE_SYNC_MANUAL);

lattice_ntt_forward_async(ctx, poly1);
lattice_ntt_forward_async(ctx, poly2);
// ... CPU work while GPU computes ...
lattice_sync(ctx);  // Wait for all operations
```

## Debugging

### Metal Validation Layer

```bash
# Enable Metal validation for debugging
export MTL_DEBUG_LAYER=1
export MTL_SHADER_VALIDATION=1

./your_program
```

### GPU Frame Capture

For profiling with Xcode Instruments:

1. Build with debug symbols: `cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo`
2. Run under Instruments with "Metal System Trace"
3. Analyze shader execution and memory transfers

## Limitations

1. **64-bit Only**: Metal on Apple Silicon is 64-bit only
2. **No FP64 in Shaders**: Metal shaders don't support double precision (our integer operations don't need it)
3. **macOS/iOS Only**: Metal is Apple-exclusive
4. **Max Threadgroup Size**: 1024 threads per threadgroup

## Related

- [CUDA Backend](/docs/backends/cuda) - NVIDIA GPU support
- [CPU Backend](/docs/backends/cpu) - Fallback implementation
- [NTT Operations](/docs/concepts/ntt) - Algorithm details
